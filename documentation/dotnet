
=== Print all config and where they come from (config is type IConfiguration)
var root = (IConfigurationRoot)config;
var debugView = root.GetDebugView();
Console.WriteLine(debugView);





=== new project startup considerations
MappingGenerator nuget package: https://github.com/cezarypiatek/MappingGenerator
custom linting, eg. error if switch not exhaustive
.net watch run configuration plugin (same as dotnet watch in 6?)
Serilog
new dotnet 6 using switch (only nontrivial usings at top)
nullable types switch

Set implicit usings and nullable
in csproj file: Project > ProjectGroup
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>



=== HTTP Client

// GET
using var httpClient = new HttpClient();
var res = await httpClient.SendAsync(new HttpRequestMessage
{
    Method = HttpMethod.Get,
    RequestUri = new Uri(url)
});
var content = await res.Content.ReadFromJsonAsync<object>();

// POST
using var httpClient = new HttpClient();
var res = await httpClient.SendAsync(new HttpRequestMessage
{
    Method = HttpMethod.Post,
    RequestUri = new Uri(url),
    Content = new StringContent(JsonSerializer.Serialize(body), Encoding.UTF8, "application/json")
});
Console.WriteLine(await res.Content.ReadAsStringAsync());
res.EnsureSuccessStatusCode();







=== JWT unpack
public static class JwtExtensions
{
    private const string BearerPrefix = "Bearer ";
    public static string TryGetString(this JwtPayload payload, string key)
    {
        if (!payload.TryGetValue(key, out var value))
            throw new ArgumentException($"JWT payload did not contain key \"{key}\"");
        return (string) value;
    }
    public static IEnumerable<T> TryGetArray<T>(this JwtPayload payload, string key)
    {
        if (!payload.TryGetValue(key, out var value))
            throw new ArgumentException($"JWT payload did not contain key \"{key}\"");
        return JsonConvert.DeserializeObject<IEnumerable<T>>(value.ToString());
    }
    public static JwtPayload TryGetJwtPayload(this HttpContext? httpContext)
    {
        // use with: var payload = _httpContextAccessor.HttpContext.TryGetJwtPayload();
        if (httpContext == null) throw new ArgumentNullException("httpContext", "There is no active HttpContext");
        var authHeader = httpContext.Request.Headers.Authorization.ToString();
        if (authHeader == "") throw new ArgumentException("No Authorization header detected");
        if (!authHeader.Contains(BearerPrefix, StringComparison.InvariantCultureIgnoreCase))
            throw new ArgumentException("No Bearer token detected. Authorization header should have format: \"Bearer SomeJWT\"");

        var handler = new JwtSecurityTokenHandler();
        var tokenS = handler.ReadToken(
            authHeader.Replace(BearerPrefix, "", StringComparison.InvariantCultureIgnoreCase)
        ) as JwtSecurityToken;
        return tokenS!.Payload;
    }
}





=== Application Insights config
// In Program.cs
Console.WriteLine($"Using ApplicationInsights ConnectionString: \"{builder.Configuration.GetValue<string>("APPLICATIONINSIGHTS_CONNECTION_STRING")}\"");
builder.Services.AddApplicationInsightsTelemetry(o =>
{
    o.ConnectionString = builder.Configuration.GetValue<string>("APPLICATIONINSIGHTS_CONNECTION_STRING");
    o.EnableAdaptiveSampling = false;
});
builder.Services.AddSingleton<ITelemetryInitializer, CustomRequestTelemetryInitializer>();
builder.Services.ConfigureTelemetryModule<DependencyTrackingTelemetryModule>((module, o) =>
{
    // log sqlstatement. TODO: see if works for cosmos
    module.EnableSqlCommandTextInstrumentation = true;
});

// In CustomRequestTelemetryInitializer.cs
// Adds information from custom headers and claims to Application insights request telemetry
public class CustomRequestTelemetryInitializer : ITelemetryInitializer
{
    private readonly IHttpContextAccessor _httpContextAccessor;
    public CustomRequestTelemetryInitializer(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }
    public void Initialize(ITelemetry telemetry)
    {
        var requestTelemetry = telemetry as RequestTelemetry;
        if (requestTelemetry == null) return;

        var headers = _httpContextAccessor.HttpContext!.Request.Headers;
        if (headers["Transaction-Id"] != "")
            requestTelemetry.Properties.Add("TransactionId", headers["Transaction-Id"]);

        var payload = _httpContextAccessor.HttpContext.TryGetJwtPayload();
        requestTelemetry.Properties.Add("UserId", payload.TryGetString("oid"));
        requestTelemetry.Properties.Add("UserEmail", payload.TryGetString("preferred_username"));
    }
}






==== Body Log middleware
// in ContentLogMiddleware.cs
using System.Text;

namespace InternalAPI.Middleware;

public class ContentLogMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ContentLogMiddleware> _logger;

    public ContentLogMiddleware(RequestDelegate next, ILogger<ContentLogMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task Invoke(HttpContext context)
    {
        if (context.Request.Method == "POST" || context.Request.Method == "PUT")
        {
            if (context.Request.ContentLength > 30_000)
            {
                _logger.LogDebug("ContentLogMiddleware: Body is more than 30KB so not logged [ContentLength:{ContentLength}]", context.Request.ContentLength);
            }
            else
            {
                context.Request.EnableBuffering();
                using StreamReader reader = new StreamReader(context.Request.Body, Encoding.UTF8, true, 1024, true);
                _logger.LogDebug(await reader.ReadToEndAsync());
                context.Request.Body.Position = 0;
            }
        }

        await _next(context);
    }
}



